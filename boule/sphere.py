"""
Module for defining and setting the reference sphere.
"""
import attr
import numpy as np

from . import Ellipsoid


# Don't let ellipsoid parameters be changed to avoid messing up calculations
# accidentally.
@attr.s(frozen=True)
class Sphere(Ellipsoid):
    """
    Reference spherical ellipsoid

    Represents ellipsoids with zero flattening (spheres). Inherits methods and
    properties of the :class:`boule.Ellipsoid`, guaranteeing no singularities
    due to zero flattening (and thus zero eccentricity).

    All parameters are in SI units.

    Parameters
    ----------
    name : str
        A short name for the ellipsoid, for example ``'MOON'``.
    radius : float
        The radius of the sphere [meters].
    geocentric_grav_const : float
        The geocentric gravitational constant (GM) [m^3 s^-2].
    angular_velocity : float
        The angular velocity of the rotating ellipsoid (omega) [rad s^-1].
    long_name : str or None
        A long name for the ellipsoid, for example ``"Moon Reference System"``
        (optional).
    reference : str or None
        Citation for the ellipsoid parameter values (optional).

    Examples
    --------

    We can define a unit sphere:

    >>> sphere = Sphere(
    ...     name="sphere",
    ...     radius=1,
    ...     geocentric_grav_const=1,
    ...     angular_velocity=0,
    ...     long_name="Spherical Ellipsoid",
    ... )
    >>> print(sphere) # doctest: +ELLIPSIS
    Sphere(name='sphere', ...)
    >>> print(sphere.long_name)
    Spherical Ellipsoid
    >>> print("{:.2f}".format(sphere.semiminor_axis))
    1.00
    >>> print("{:.2f}".format(sphere.mean_radius))
    1.00
    >>> print("{:.2f}".format(sphere.flattening))
    0.00
    >>> print("{:.2f}".format(sphere.linear_eccentricity))
    0.00
    >>> print("{:.2f}".format(sphere.first_eccentricity))
    0.00
    >>> print("{:.2f}".format(sphere.second_eccentricity))
    0.00
    >>> print(sphere.normal_gravity(latitude=0, height=1))
    25000.0
    >>> print(sphere.normal_gravity(latitude=90, height=1))
    25000.0
    """

    name = attr.ib()
    radius = attr.ib()
    geocentric_grav_const = attr.ib()
    angular_velocity = attr.ib()
    long_name = attr.ib(default=None)
    reference = attr.ib(default=None)
    # semimajor_axis and flattening shouldn't be defined on initialization:
    #   - semimajor_axis will be equal to radius
    #   - flattening will be equal to zero
    semimajor_axis = attr.ib(init=False)
    flattening = attr.ib(init=False, default=0)

    @semimajor_axis.default
    def _set_semimajor_axis(self):
        "The semimajor axis should be the radius"
        return self.radius

    def normal_gravity(self, latitude, height):
        r"""
        Calculate normal gravity at any latitude and height

        Computes the magnitude of the gradient of the gravity potential
        (gravitational + centrifugal) generated by the sphere at the given
        latitude and height:

        .. math::

            \gamma =
            \sqrt{\left( \frac{GM}{r^2} \right)^2
            + \left(\omega^2 r - 2\frac{GM}{r^2} \right) \omega^2 r \cos^2 \varphi}

        .. warning::

            A sphere under rotation is not in hydrostatic equilibrium,
            therefore they are not their own equipotential gravity surface.

        Parameters
        ----------
        latitude : float or array
            The latitude where the normal gravity will be computed (in degrees).
        height : float or array
            The height (above the sphere) of computation point (in meters).

        Returns
        -------
        gamma : float or array
            The normal gravity in mGal.

        References
        ----------
        [Heiskanen-Moritz]_
        """
        radial_distance = self.radius + height
        gravity_acceleration = self.geocentric_grav_const / (radial_distance) ** 2
        return 1e5 * np.sqrt(
            gravity_acceleration ** 2
            + (self.angular_velocity ** 2 * radial_distance - 2 * gravity_acceleration)
            * self.angular_velocity ** 2
            * radial_distance
            # replace cos^2 with (1 - sin^2) for more accurate results on the pole
            * (1 - np.sin(np.radians(latitude)) ** 2)
        )

    @property
    def gravity_equator(self):
        """
        The norm of the gravity vector at the equator on the sphere [m/s^2]

        Overrides the inherited method from :class:`boule.Ellipsoid` to avoid
        singularities due to zero flattening.
        """
        return (
            self.geocentric_grav_const / self.radius ** 2
            - self.radius * self.angular_velocity ** 2
        )

    @property
    def gravity_pole(self):
        """
        The norm of the gravity vector at the poles on the sphere [m/s^2]

        Overrides the inherited method from :class:`boule.Ellipsoid` to avoid
        singularities due to zero flattening.
        """
        return self.geocentric_grav_const / self.radius ** 2
