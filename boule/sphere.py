"""
Module for defining and setting the reference sphere.
"""
from warnings import warn

import attr
import numpy as np

from . import Ellipsoid


# Don't let ellipsoid parameters be changed to avoid messing up calculations
# accidentally.
@attr.s(frozen=True)
class Sphere(Ellipsoid):
    """
    Reference sphere (zero flattening ellipsoids)

    Inherits methods and properties of the :class:`boule.Ellipsoid` while
    guaranteeing no singularities due to zero flattening (and thus zero
    eccentricity) in gravity calculations.

    All parameters are in SI units.

    Parameters
    ----------
    name : str
        A short name for the ellipsoid, for example ``'MOON'``.
    radius : float
        The radius of the sphere [meters].
    geocentric_grav_const : float
        The geocentric gravitational constant (GM) [m^3 s^-2].
    angular_velocity : float
        The angular velocity of the rotating ellipsoid (omega) [rad s^-1].
    long_name : str or None
        A long name for the ellipsoid, for example ``"Moon Reference System"``
        (optional).
    reference : str or None
        Citation for the ellipsoid parameter values (optional).

    Examples
    --------

    We can define a unit sphere:

    >>> sphere = Sphere(
    ...     name="sphere",
    ...     radius=1,
    ...     geocentric_grav_const=1,
    ...     angular_velocity=0,
    ...     long_name="Spherical Ellipsoid",
    ... )
    >>> print(sphere) # doctest: +ELLIPSIS
    Sphere(name='sphere', ...)
    >>> print(sphere.long_name)
    Spherical Ellipsoid
    >>> print("{:.2f}".format(sphere.semiminor_axis))
    1.00
    >>> print("{:.2f}".format(sphere.mean_radius))
    1.00
    >>> print(sphere.normal_gravity(latitude=0, height=1))
    25000.0
    >>> print(sphere.normal_gravity(latitude=90, height=1))
    25000.0

    The flattening and eccentricities will all be zero:

    >>> print("{:.2f}".format(sphere.flattening))
    0.00
    >>> print("{:.2f}".format(sphere.linear_eccentricity))
    0.00
    >>> print("{:.2f}".format(sphere.first_eccentricity))
    0.00
    >>> print("{:.2f}".format(sphere.second_eccentricity))
    0.00

    """

    name = attr.ib()
    radius = attr.ib()
    geocentric_grav_const = attr.ib()
    angular_velocity = attr.ib()
    long_name = attr.ib(default=None)
    reference = attr.ib(default=None)
    # semimajor_axis and flattening shouldn't be defined on initialization:
    #   - semimajor_axis will be equal to radius
    #   - flattening will be equal to zero
    semimajor_axis = attr.ib(init=False)
    flattening = attr.ib(init=False, default=0)

    @semimajor_axis.default
    def _set_semimajor_axis(self):
        "The semimajor axis should be the radius"
        return self.radius

    @radius.validator
    def _check_radius(
        self, radius, value
    ):  # pylint: disable=no-self-use,unused-argument
        """
        Check if the radius is positive
        """
        if not value > 0:
            raise ValueError(f"Invalid radius '{value}'. Should be greater than zero.")

    @geocentric_grav_const.validator
    def _check_geocentric_grav_const(
        self, geocentric_grav_const, value
    ):  # pylint: disable=no-self-use,unused-argument
        """
        Warn if geocentric_grav_const is negative
        """
        if value < 0:
            warn(f"The geocentric gravitational constant is negative: '{value}'")

    def normal_gravity(self, latitude, height):
        r"""
        Calculate normal gravity at any latitude and height

        Computes the magnitude of the gradient of the gravity potential
        (gravitational + centrifugal) generated by the sphere at the given
        latitude :math:`\theta` and height :math:`h`:

        .. math::

            \gamma(\theta, h) =
            \sqrt{\left( \frac{GM}{(R + h)^2} \right)^2
            + \left(\omega^2 (R + h) - 2\frac{GM}{(R + h)^2} \right)
            \omega^2 (R + h) \cos^2 \theta}

        in which :math:`R` is the sphere radius, :math:`G` is the gravitational
        constant, :math:`M` is the mass of the sphere, and :math:`\omega` is
        the angular velocity.

        .. note::

            A sphere under rotation is not in hydrostatic equilibrium.
            Therefore, it is not it's own equipotential gravity surface (as is
            the case for the ellipsoid) and the normal gravity vector is not
            normal to the surface of the sphere.

        Parameters
        ----------
        latitude : float or array
            The latitude where the normal gravity will be computed (in
            degrees). For a reference sphere there is no difference between
            geodetic and spherical latitudes.
        height : float or array
            The height (above the sphere) of the computation point (in meters).

        Returns
        -------
        gamma : float or array
            The normal gravity in mGal.

        References
        ----------
        [Heiskanen-Moritz]_

        """
        radial_distance = self.radius + height
        gravity_acceleration = self.geocentric_grav_const / (radial_distance) ** 2
        return 1e5 * np.sqrt(
            gravity_acceleration ** 2
            + (self.angular_velocity ** 2 * radial_distance - 2 * gravity_acceleration)
            * self.angular_velocity ** 2
            * radial_distance
            # replace cos^2 with (1 - sin^2) for more accurate results on the pole
            * (1 - np.sin(np.radians(latitude)) ** 2)
        )

    @property
    def gravity_equator(self):
        """
        The norm of the gravity vector at the equator on the sphere [m/s^2]

        Overrides the inherited method from :class:`boule.Ellipsoid` to avoid
        singularities due to zero flattening.
        """
        return (
            self.geocentric_grav_const / self.radius ** 2
            - self.radius * self.angular_velocity ** 2
        )

    @property
    def gravity_pole(self):
        """
        The norm of the gravity vector at the poles on the sphere [m/s^2]

        Overrides the inherited method from :class:`boule.Ellipsoid` to avoid
        singularities due to zero flattening.
        """
        return self.geocentric_grav_const / self.radius ** 2
