"""
Module for defining and setting the reference sphere.
"""
import attr
import numpy as np

from . import Ellipsoid


# Don't let ellipsoid parameters be changed to avoid messing up calculations
# accidentally.
@attr.s(frozen=True)
class Sphere(Ellipsoid):
    """
    Reference spherical ellipsoid

    Represents ellipsoids with zero flattening (spheres). Inherits methods and
    properties of the :class:`boule.Ellipsoid`, guaranteeing no singularities
    due to zero flattening (and thus zero eccentricity).

    All parameters are in SI units.

    Parameters
    ----------
    name : str
        A short name for the ellipsoid, for example ``'MOON'``.
    radius : float
        The radius of the sphere [meters].
    geocentric_grav_const : float
        The geocentric gravitational constant (GM) [m^3 s^-2].
    angular_velocity : float
        The angular velocity of the rotating ellipsoid (omega) [rad s^-1].
    long_name : str or None
        A long name for the ellipsoid, for example ``"Moon Reference System"``
        (optional).
    reference : str or None
        Citation for the ellipsoid parameter values (optional).

    Examples
    --------

    We can define a unit sphere:

    >>> sphere = Sphere(
    ...     name="sphere",
    ...     radius=1,
    ...     geocentric_grav_const=1,
    ...     angular_velocity=0,
    ...     long_name="Spherical Ellipsoid",
    ... )
    >>> print(sphere) # doctest: +ELLIPSIS
    Sphere(name='sphere', ...)
    >>> print(sphere.long_name)
    Spherical Ellipsoid
    >>> print("{:.2f}".format(sphere.semiminor_axis))
    1.00
    >>> print("{:.2f}".format(sphere.mean_radius))
    1.00
    >>> print("{:.2f}".format(sphere.flattening))
    0.00
    >>> print("{:.2f}".format(sphere.linear_eccentricity))
    0.00
    >>> print("{:.2f}".format(sphere.first_eccentricity))
    0.00
    >>> print("{:.2f}".format(sphere.second_eccentricity))
    0.00
    >>> print(sphere.normal_gravity(latitude=0, height=1))
    25000.0
    >>> print(sphere.normal_gravity(latitude=90, height=1))
    25000.0
    """

    name = attr.ib()
    radius = attr.ib()
    geocentric_grav_const = attr.ib()
    angular_velocity = attr.ib()
    long_name = attr.ib(default=None)
    reference = attr.ib(default=None)
    # semimajor_axis and flattening shouldn't be defined on initialization:
    #   - semimajor_axis will be equal to radius
    #   - flattening will be equal to zero
    semimajor_axis = attr.ib(init=False)
    flattening = attr.ib(init=False, default=0)

    @semimajor_axis.default
    def _set_semimajor_axis(self):
        "The semimajor axis should be the radius"
        return self.radius

    def normal_gravity(self, latitude, height):
        r"""
        Calculate radial component of normal gravity at any latitude and height

        .. warning::

            Spheres that are under rotation cannot be their own equipotential
            surfaces and aren't in hydrostatic equilibrium.

        Computes the radial component of the gradient of the gravity potential
        (gravitational + centrifugal) generated by the sphere at the given
        latitude and height:

        .. math::

            \gamma = \frac{GM}{r^2} - r \omega \cos^2 \varphi

        This functions computes the normal gravity as the radial component of
        the gradient of the gravity potential to be in agreement with the
        Somigliana equation on the surface of the sphere.

        Parameters
        ----------
        latitude : float or array
            The latitude where the normal gravity will be computed (in degrees).
        height : float or array
            The height (above the sphere) of computation point (in meters).

        Returns
        -------
        gamma : float or array
            The radial component of the normal gravity in mGal.

        References
        ----------
        [Heiskanen-Moritz]_

        See also
        --------
        :meth:`normal_gravity_norm`
        :meth:`normal_gravity_no_rotation`
        """
        return 1e5 * (
            self.normal_gravity_no_rotation(height)
            - self.angular_velocity ** 2 * (self.radius + height)
            # replace cos^2 with (1 - sin^2) for more accurate results on the pole
            * (1 - np.sin(np.radians(latitude)) ** 2)
        )

    def normal_gravity_norm(self, latitude, height):
        r"""
        Calculate the norm of the normal gravity vector at any latitude and height

        .. warning::

            Spheres that are under rotation cannot be their own equipotential
            surfaces and aren't in hydrostatic equilibrium.

        Computes the magnitude of the gradient of the gravity potential
        (gravitational + centrifugal) generated by the sphere at the given
        latitude and height:

        .. math::

            \gamma =
            \sqrt{\left( \frac{GM}{r^2} \right)^2
            + \left(\omega^2 r - 2\frac{GM}{r^2} \right) \omega^2 r \cos^2 \varphi}

        Parameters
        ----------
        latitude : float or array
            The latitude where the normal gravity will be computed (in degrees).
        height : float or array
            The height (above the sphere) of computation point (in meters).

        Returns
        -------
        gamma : float or array
            The norm of the normal gravity in mGal.

        References
        ----------
        [Heiskanen-Moritz]_

        See also
        --------
        :meth:`normal_gravity`
        :meth:`normal_gravity_no_rotation`
        """
        radial_distance = self.radius + height
        gravity_acceleration = self.normal_gravity_no_rotation(height)
        return 1e5 * np.sqrt(
            gravity_acceleration ** 2
            + (self.angular_velocity ** 2 * radial_distance - 2 * gravity_acceleration)
            * self.angular_velocity ** 2
            * radial_distance
            # replace cos^2 with (1 - sin^2) for more accurate results on the pole
            * (1 - np.sin(np.radians(latitude)) ** 2)
        )

    def normal_gravity_no_rotation(self, height):
        r"""
        Compute norm of gravity acceleration considering no rotation [m/s^2]

        .. math::

            \gamma = \frac{GM}{r^2}

        Parameters
        ----------
        height : float or array
            The height (above the sphere) of computation point (in meters).

        Returns
        -------
        gamma : float or array
            The norm of the gravity aceleration (without centrifugal term) [m/s^2]

        References
        ----------
        [Heiskanen-Moritz]_

        See also
        --------
        :meth:`normal_gravity`
        :meth:`normal_gravity_norm`
        """
        return self.geocentric_grav_const / (self.radius + height) ** 2

    @property
    def gravity_equator(self):
        """
        The norm of the gravity vector at the equator on the sphere [m/s^2]

        Overrides the inherited method from :class:`boule.Ellipsoid` to avoid
        singularities due to zero flattening.
        """
        return (
            self.geocentric_grav_const / self.radius ** 2
            - self.radius * self.angular_velocity ** 2
        )

    @property
    def gravity_pole(self):
        """
        The norm of the gravity vector at the poles on the sphere [m/s^2]

        Overrides the inherited method from :class:`boule.Ellipsoid` to avoid
        singularities due to zero flattening.
        """
        return self.geocentric_grav_const / self.radius ** 2
